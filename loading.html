<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Millennium Falcon</title>
  <style>
    body {
      margin: 0; height: 100dvh; overflow: hidden; width: 100vw;
      /* filter: invert(1); */
    }

    #isLoading {
      position: absolute;
      top: 75vh;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      color: white;
      text-align: center;
      padding: 20px 40px;
      border-radius: 10px;
      user-select: none;
      text-shadow: rgba(255, 255, 255, 0.791) 0 0 50px;
    }
    canvas {
      width: 100vw; height: 100dvh; pointer-events: none;
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@v0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@v0.163.0/examples/jsm/"
        }
      }
    </script>
</head>

<body>
  <script type="module">import * as THREE from 'three';

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'low-power', alpha: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.shadowMap.enabled = false;
    document.body.appendChild(renderer.domElement);

    // Адаптация под изменение размера экрана
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    const scene = new THREE.Scene();
    renderer.setClearColor(0x000000, 0);

    const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
    const fov = isMobile ? 35 : 45;
    const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(8, 8, isMobile ? 3 : 3);
    camera.lookAt(scene.position);
    scene.add(camera);

    const image = new Image();
    image.src = 'LoadingCube.png';

    image.onerror = () => {
      console.error('Failed to load image at LoadingCube.png');
      // Fallback: Create a debug texture
      const canvas = document.createElement('canvas');
      canvas.width = 384;
      canvas.height = 384;
      const ctx = canvas.getContext('2d');
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          ctx.fillStyle = `hsl(${(row * 3 + col) * 40}, 50%, 50%)`;
          ctx.fillRect(col * 128, row * 128, 128, 128);
          ctx.fillStyle = 'white';
          ctx.font = '40px Arial';
          ctx.fillText(row * 3 + col, col * 128 + 50, row * 128 + 80);
        }
      }
      const texture = new THREE.CanvasTexture(canvas);
      setupScene(texture);
    };

    image.onload = () => {
      const partSize = 128;
      const atlasSize = partSize * 3; // 384x384
      const canvas = document.createElement('canvas');
      canvas.width = atlasSize;
      canvas.height = atlasSize;
      const ctx = canvas.getContext('2d');

      // Ensure image is drawn correctly
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          ctx.drawImage(
            image,
            (col * image.width) / 3, (row * image.height) / 3, image.width / 3, image.height / 3,
            col * partSize, row * partSize, partSize, partSize
          );
        }
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.format = THREE.RGBAFormat; // Fix for sRGB warning
      texture.type = THREE.UnsignedByteType;
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = true;

      setupScene(texture);
    };

    function setupScene(texture) {
      // Геометрия с UV-координатами
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const uvAttribute = geometry.attributes.uv;

      // Исправленные UV-координаты для корректного отображения
      const uvMap = [
        // Грань 0 (Face 1): часть (0,2) — верхний левый квадрат
        [1 / 3, 1 / 3, 1 / 3, 0 / 3, 2 / 3, 1 / 3, 2 / 3, 0 / 3],
        // Грань 1 (Face 2): часть (1,2) — верхний средний
        [1 / 3, 3 / 3, 1 / 3, 2 / 3, 2 / 3, 3 / 3, 2 / 3, 2 / 3],
        // Грань 2 (Face 3): часть (2,2) — верхний правый
        [2 / 3, 3 / 3, 2 / 3, 2 / 3, 3 / 3, 3 / 3, 3 / 3, 2 / 3],
        // Грань 3 (Face 4): часть (0,1) — средний левый
        [0 / 3, 2 / 3, 0 / 3, 1 / 3, 1 / 3, 2 / 3, 1 / 3, 1 / 3],
        // Грань 4 (Face 5): часть (1,1) — средний центр
        [1 / 3, 2 / 3, 1 / 3, 1 / 3, 2 / 3, 2 / 3, 2 / 3, 1 / 3],
        // Грань 5 (Face 6): часть (2,1) — средний правый
        [2 / 3, 2 / 3, 2 / 3, 1 / 3, 3 / 3, 2 / 3, 3 / 3, 1 / 3],
      ];

      for (let face = 0; face < 6; face++) {
        for (let i = 0; i < 4; i++) {
          const idx = face * 4 + i;
          uvAttribute.setXY(idx, uvMap[face][i * 2], uvMap[face][i * 2 + 1]);
        }
      }

      const material = new THREE.MeshBasicMaterial({ map: texture });
      const count = 27;
      const mesh = new THREE.InstancedMesh(geometry, material, count);
      scene.add(mesh);

      const origins = [];
      const directions = [];
      const phases = [];
      const smallSize = 1;
      const spacing = 0.05;

      let i = 0;
      for (let x = 0; x < 3; x++) {
        for (let y = 0; y < 3; y++) {
          for (let z = 0; z < 3; z++) {
            const pos = new THREE.Vector3(
              (x - 1) * (smallSize + spacing),
              (y - 1) * (smallSize + spacing),
              (z - 1) * (smallSize + spacing)
            );
            origins.push(pos);
            directions.push(pos.clone().normalize());
            phases.push(Math.random() * Math.PI * 2);
            i++;
          }
        }
      }

      const dummy = new THREE.Object3D();
      const rotationVelocity = {
        x: 0.01 * (Math.random() - 0.5),
        y: 0.01 * (Math.random() - 0.5),
        z: 0.01 * (Math.random() - 0.5)
      };

      let lastTime = 0;
      const updateInterval = 16;

      function animate(time) {
        if (document.hidden) {
          requestAnimationFrame(animate);
          return;
        }

        requestAnimationFrame(animate);

        mesh.rotation.x += rotationVelocity.x * 3;
        mesh.rotation.y += rotationVelocity.y * 3;
        mesh.rotation.z += rotationVelocity.z * 3;

        rotationVelocity.x += 0.0009 * (Math.random() - 0.5);
        rotationVelocity.y += 0.0009 * (Math.random() - 0.5);
        rotationVelocity.z += 0.0009 * (Math.random() - 0.5);

        if (time - lastTime >= updateInterval) {
          for (let i = 0; i < count; i++) {
            const offset = Math.sin(time * 0.002 + phases[i]) * 0.3;
            const pos = origins[i].clone().addScaledVector(directions[i], offset);
            dummy.position.copy(pos);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
          }
          mesh.instanceMatrix.needsUpdate = true;
          lastTime = time;
        }

        renderer.render(scene, camera);
      }

      animate(performance.now());
    }</script>
  <!-- <div id="isLoading">...Loading...</div> -->
</body>

</html>